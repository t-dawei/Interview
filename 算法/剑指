1. 单利模式
    __new__(cls)

2. 数组（字符串）
    数组中重复数字
            数组中重复数字 ----> hash
            1-n ---> 索引对应
            有序数组 --> 两次二分查找
    旋转数组的最小数字/旋转数组查找数字 ----> 二分查找
    数组中出现次数超过一半的数字 ---> hash、 排序、partition函数
    数组中最小的K个数 -----> partition函数 堆
    数组中的中位数 -----> partition函数

    数据流中的中位数 -----> 左边最大堆，右边最小堆
    数组中的逆序对 -----> 归并排序

    排序数组中查找数字出现的次数/数字的起始位置 ------> 两次二分法
    两个有序数组查找中位数 -----> o(m+n) 双指针 / o(log(min(m, n))) ---> 二分法 查找m1
    数组所能围城的最大容器面积 -----> 双指针法
    数组中三位数之和为0/四位数之和 ----> 双指针法

3. 栈与队列
    两个栈实现队列 -----> 入一个栈，出一个栈
    两个队列实现一个栈   ----> 一个存数据，一个始终为空
    包含min函数的栈 ------> 双栈
    包含max函数的队列 ----> 双队列

4. 贪心与动态规划(子问题-> 状态定义 -> 状态转移)
    a. 贪心
        把数组排成最小的数

    b. 一维动态规划
        剪绳子乘积最大：动划：dp[i] 表示长度为n的绳子的最大划分乘机（贪心 尽可能3 4分22）
        连续子数组的最大和：动规：dp[i] 表示以第i个字符结尾的子数组的最大和
        求两个子数组的最大和：动规：dp[i] 表示以第i个字符结尾的子数组的最大和 + 从后往前在算一次 相加取最大值
        最长不含重复字符的子字符串：动规：dp[i] 表示以第i个字符结尾的不重复字符的最大长度 + hash字典(保存字符上一次出现的位置)
        第i个丑数：动规：dp[i] 表示第i个丑数


    c. 二维动态规划
        最长回文子串 ： dp[i][j] 表示s[i:j+1] 是否为回文子串 
        字符串1到字符串2的最小转化次数： dp[i][j] 表示字符串str[:i] 到字符串str[:j]的最小转换次数
        二维数组左上到右下角的路径最大礼物价值：dp[i][j] 表示从起始结点到当前结点 matrix[i][j] 的最大礼物值

6. 位运算
    数字转化为二进制中1的个数 -- 与运算 + 右移运算

7. 链表
    删除链表中的结点 ---> 复制 删除后一个
    链表中的倒数第K个结点  ----> 快慢指针
    反转列表   ----> 3个指针
    链表中环的位置（是否有环）-----> 快慢指针、a == c + (n-1)r
    两个链表的第一个公共节点 -----> 栈、快慢指针

8. 树
    二叉树镜像 ---> 交换左右子结点 递归
    对称二叉树 ----> 中序遍历 递归
    判断数组是否为二叉搜索树的后序遍历 ----> 根结点划分 递归
    二叉树中和为某一值的路径 -----> 递归
    二叉搜索树与排序后双向链表 ----> 中序遍历
    序列化二叉树 ----> 前序遍历

10. 递归回溯剪枝
    数组组合某值（重复用与不能重复用）
    数组中数字的全排列 （数组中数字重复与唯一）
    数组中数字的子集 （数组中数字重复与唯一）

    m * n 矩阵 机器人的运动范围 --> 递归回溯







